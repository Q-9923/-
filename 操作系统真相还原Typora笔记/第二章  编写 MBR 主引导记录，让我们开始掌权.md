## 第二章  编写 MBR 主引导记录，让我们开始掌权

### 2.1 计算机的启动过程

#### 载入程序(大概分两部分)：

![1737876295687](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737876295687.png)

#### 标注cs：ip   ：

1. cs是代码段寄存器，用于存放代码的段地址，IP是指令指针寄存器，指向当前正在执行的指令在代码段中的偏移地址
2. 这两者结合起来确定了下一条要执行的指令的内存地址，控制程序的执行流程
3. cpu在执行指令时，会将cs寄存器中的段地址与ip寄存器中的编译地址组合，形成物理地址，从而从内存中读取相应的指令。
4. <u>物理地址=CS x 16+IP</u>；将cs的内容左移四位（相当于乘以16），再与IP的内容相加，就得到了cpu要读取的下一条指令的物理地址。

### 2.2 软件接力第一棒，BIOS

#### BIOS：基本输入输出系统

 BIOS建立的功能即是对硬件的IO操作，即输入输出，但并不可能实现面面俱到，（在实模式下）所以调重要的，保证计算机能运行的那些硬件基本IO操作，故被称作“基本”

拓：保护模式：

![1737880524501](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737880524501.png)

#### 为什么插在主板上的物理内存不是cpu眼里的“全部内存”：

地址总线宽度决定可以访问的内存大小

物理内存（内存条）

原因：除了插在主板上的内存条需要通过地址总线访问，其他设备也同样需要，所以，会在地址总线上提前预留出一些地址空间给外设用。

所以内存条即使没有超过地址总线的范围，也不会全部被询问到，毕竟要预留一点给其他外设，（最终还得看地址总线把地址指向哪块内存了）

表示地址的那串数字是地址总线的输入，相当于其参数，和内存条没关系

![1737881242624](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737881242624.png)



#### BIOS的苏醒

BIOS是由硬件加载的，被写入只读存储器ROM

在8086计算机开机（接电的瞬间）时，CPU的cs:ip寄存器被强制初试化为0xF000:0xFFF0。在<u>实模式</u>下由于CPU访问的内存是段地址+偏移地址的方式来实现的，所以0xF000:0xFFF0，访问的地址是0xF000*16+0xFFF0=0xFFFF0。

![1737878759603](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737878759603.png)

（BIOS本身是个程序，程序要执行，就要有入口地址，这个入口地址便是0xFFFF0）0xFFFF0这个地址存放着一条指令，该指令内容是跳转至[BIOS](https://so.csdn.net/so/search?q=BIOS&spm=1001.2101.3001.7020)程序的入口（该指令由跳转指令与BIOS程序的入口地址组成，共16B)。

#### BIOS的主要功能：

1. 检测，初始化硬件（如何初始化：硬件自己提供了初始化的功能调用，BIOS可以直接调用）
2. 建立中断向量表（这样就可以通过“int 中断号”来实现相关的硬件调用）
3. 校验启动盘中位于0盘0道1扇区（其实就是0扇区，只不过CHS方法用1开头）（而LBA方式是从0开始）的内容，校验这里是不是放着主引导记录MBR，校验方法是检测这个扇区最后两个字节是不是0x55与0xaa（我们编写的主引导记录MBR最后两个字节也应该是这两个）
4. 在3的基础上是，那么就将该扇区内容加载至0x7c00（下面详细解释）内存处。加载完毕后，然后跳转过去执行。

#### 关于0x7c00：

属于BIOS中的规范

MBR不能随便放在哪里，首先，不能覆盖已有数据，其次，不能过早的被其他数据覆盖（即不能让mbr破坏自己）

在DOS 1.0（早期的磁盘操作系统版本）要求的最小内存32KB，MBR留给他们尽可能多的预留空间，以及为避免过早被覆盖，保全自己，MBR最好放在32KB的结尾

MBR本身也是程序，需要用到栈（是程序就要用到栈），栈也在内存中，即MBR虽本身只有512字节，还是要为栈留下空间，所以实际所用内存空间要大于512字节，1KB即够

综上，即选择32KB的最后1KB，换算为十六进制即32KB（0x8000）-1KB（0x400）=0x7c00

也由此可见，加载MBR的位置取决于操作系统本身所占内存大小和内存布局

### 2.3 让MBR先飞一会儿

MBR 的大小必须是 512 字节，这是为了保证 0x55 和 0xaa 这两个魔数恰好出现在该扇区的最后两个字节处，即第 510 字节处和第 511 字节处，这是按起始偏移为 0 算起的。

(主引导记录(MBR)的最后两个字节的内容是0x55和0xaa，BIOS 会用它来校验该扇区是否可引导。这是一种约定俗成的标识，BIOS通过检测到这两个字节，就知道这个扇区里面有可加载的程序。)

MBR的任务就是加载loader，由loader加载操作系统到指定位置，然后执行加载过来的操作系统。MBR大小必须是512字节，这是为了占满硬盘0盘0道1扇区，且最最后两个字节必须是0x55与0xaa。

#### 关于$和$$，以及section

$和$$是编译器 NASM 预留的关键字，用来表示当前行和本段 的地址，起到了标号的作用，由NASM 提供的，而并不是 CPU 原生支持的，相当于伪指令一样，对 CPU 来说是假的。

（指令本来没有真伪之别，伪指令是相对于 CPU可识别的指令来说的，伪指令只是编译器定义的，而CPU 中并不存在这个指令）

$属于“隐式地”藏在本行代码前的标号，也就是编译器给当前行安排的地址，看不到却又无处不在，只有“显示地”用了$的地方，nasm 编译器才会将此行的地址公布出来。

$$指代本 section 的起始地址，此地址也是编译器给安排的。

默认情况下，它们（$和$$）的值是相对于本文件开头的偏移量。而实际安排的是多少，在于程序员是否在 section 中添加了 vstart关键字，它可以影响编译器安排地址的行为。

如果该 section 用了 vstart=xxxx 修饰，$$的值则是此 section 的虚拟起始地址 xxxx。$的值是以 xxxx 为起始地址的顺延。

如果用了 vstart 关键字，想获得本 section 在文件中的真实偏移 量（真实地址），则用section.节名.start。（由nasm 编译器提供）

如果没有定义 section，nasm 默认全部代码同为一个 section，起始地址为 0。

section 即是程序中的一小块，属于伪指令，CPU 运行程序不需要，只是程序员规划程序用，有了 section，可以将自己的代码分成一段一段的（在逻辑上的段）实际上编译出来的程序还是完整的一体。

程序内部的关联是通过地址实现的。

#### NASM的简单用法

-o 就是指定输出可执行文件的名称。

-f 是用来指定输出文件的格式

-hf，可以知道有多少种有效的输出格式

![1737887046664](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737887046664.png)

![1737887064262](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737887064262.png)

bin为默认输出格式，所以只需要在输出elf格式时用-f

bin：纯二进制，即直接给 CPU 后就能用，就是可执行文件中什么样，内存中就什么样。而 像elf 或 pe 格式的二进制可执行文件，里面存在和指令无关的东西，（如程序的内存布局、位置等信息，用来操作系统中的程序加载器，属于操作系统规划的范畴了）

#### MBR代码（p61）

```
                                ;主引导程序 
                                ;------------------------------------------------------------
SECTION MBR vstart=0x7c00         
    mov ax,cs                   ;此时cs寄存器为0，自然可以用来将ax寄存器置0
    mov ds,ax
    mov es,ax
    mov ss,ax
    mov fs,ax
    mov sp,0x7c00

                                ; 清屏 利用0x06号功能，上卷全部行，则可清屏。
                                ; -----------------------------------------------------------
                                ;INT 0x10   功能号:0x06	   功能描述:上卷窗口
                                ;------------------------------------------------------
                                ;输入：
                                ;AH 功能号= 0x06
                                ;AL = 上卷的行数(如果为0,表示全部)
                                ;BH = 上卷行属性
                                ;(CL,CH) = 窗口左上角的(X,Y)位置
                                ;(DL,DH) = 窗口右下角的(X,Y)位置
                                ;无返回值：
    mov ax, 0x600               ;ah中输入功能号
    mov bx, 0x700               ;设置上卷行属性，0x70表示用黑底白字的属性填充空白行
    mov cx, 0                   ;左上角: (0, 0)
    mov dx, 0x184f	            ;右下角: (80,25),
			                    ;VGA文本模式中,一行只能容纳80个字符,共25行。
			                    ;下标从0开始,所以0x18=24,0x4f=79
    int 0x10                    ;int 0x10

                                ;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;
    mov ah, 3		            ;输入: 3号子功能是获取光标位置,需要存入ah寄存器
    mov bh, 0		            ;bh寄存器存储的是待获取光标的页号

    int 0x10		            ;输出: ch=光标开始行,cl=光标结束行
		    	                ;dh=光标所在行号,dl=光标所在列号

                                ;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;

                                ;;;;;;;;;     打印字符串    ;;;;;;;;;;;
                                ;还是用10h中断,不过这次是调用13号子功能打印字符串
    mov ax, message 
    mov bp, ax		            ; es:bp 为串首地址, es此时同cs一致，
			                    ; 开头时已经为sreg初始化

                                ; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略
    mov cx, 5		            ; cx 为串长度,不包括结束符0的字符个数
    mov ax, 0x1301	            ; 子功能号13是显示字符及属性,要存入ah寄存器,
			                    ; al设置写字符方式 ah=01: 显示字符串,光标跟随移动
    mov bx, 0x2		            ; bh存储要显示的页号,此处是第0页,
			                    ; bl中是字符属性, 属性黑底绿字(bl = 02h,07是黑底白字)
    int 0x10		            ; 执行BIOS 0x10 号中断
                                ;;;;;;;;;      打字字符串结束	 ;;;;;;;;;;;;;;;

    jmp $		                ; 使程序悬停在此

    message db "1 MBR"
    times 510-($-$$) db 0
    db 0x55,0xaa


```

1.代码功能：

该MBR不用于加载，而是在屏幕上打印字符串“1 MBR”，背景色为黑色，前景色为绿色

2.实现原理：

用8086汇编语言编写显示字符的程序。该程序共512字节（不足部分补0），且最后两个字节是0x55与0xaa。该程序用NASM编译后，用dd命令写入bochs启动硬盘的0盘0道1扇区，BIOS会自动加载程序到内存中的指定位置（即0x7c00），然后自动跳转执行该程序。

3.代码逻辑：

A、清屏

B、获取光标位置

C、在光标位置处打印字符串

4.怎么写代码？
查询：

BIOS中断使用用法：https://blog.csdn.net/MENGmei0219/article/details/126785698，然后根据具体中断的需求，往所需要的所有寄存器送入值。

A、指定本程序的起始地址0x7c00，为的是告诉编译器把本程序的起始地址编译为0x7c00；

B、调用bios中断清屏；

C、调用bios中断获取光标位置；

D、调用bios中断打印字符；

E、死循环(避免程序跳走，进行悬停操作）（while （1））；然后填入MBR规定510字节大小剩下的0；固定结尾两字节0x55,0xaa

#### 关于此代码的一些解释与补充：

1.SECTION 是写汇编代码的固定格式，vstart=0x7c00”表示本程序在编译时，告诉编译器，把起始地址编译为 0x7c00。 （人为指定虚拟地址）

2.用 cs 寄存器的值去初始化其他寄存器。由于 BIOS 是通过 jmp 0：0x7c00 跳转到 MBR 的，故 cs 此时为 0。而对于 ds、es、fs、gs 这类 sreg，CPU 中不能直接给它们赋值，没有从立即数到段寄存器的电路实现， 只有通过其他寄存器来中转，这里用的是通用寄存器 ax 来中转。

3.初始化栈指针，在 CPU 上运行的程序得遵从 CPU 的规则，mbr 也是程序，是程序就要用到 栈。 0x7c00 以下暂时是安全的区域，就把它当作栈来用。 因为MBR（可能会有push操作）一些暂时用到的值会放在内存中。栈顶指针：从高地址向低地址进行延伸

4.清屏。（06h）上卷=上滚，把整个屏幕的内容整体向上移动，即清屏。因为在 BIOS 工作中，会有一些输出，如检测硬件的结果信息。为了让大家看清楚我们在 MBR 中的输出字符串，故先把 BIOS 的输出清掉，这里演示的是 BIOS 中断 int 0x10 的用法。

5.先获取光标位置，目的是避免打印字符混乱，覆盖别人的输出。

6.往光标处打印字符。

![1737895053634](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737895053634.png)



sreg：段寄存器

times 510-($-$$) db 0：用 510 字节减去上面通过$-$$ 得到的偏移量，其结果便是本扇区内的剩余量，也就是要填充的字节数。要重复进行多少次操作（引入了公式），变成了很多0

使用nasm编译该.S文件：

nasm -o mbr mbr.S

用dd命令写入bochs的硬盘：

dd if=/home/yr/桌面/test of=/home/yr/桌面/bochs/hd60M.img bs=512 count=1 conv=notrunc

补充：命令整体功能

dd 是一个在类 Unix 系统（如 Linux、macOS 等）中用于复制文件并对内容进行转换和格式化的强大命令。该命令的主要功能是将指定输入文件的前 512 字节复制到指定的输出文件中，同时不截断输出文件的原有内容。

各参数解释：

if=/home/yr/桌面/test if 是 input file 的缩写，用于指定输入文件的路径。这里指定的输入文件是/home/yr/桌面/test，即从该文件读取数据。
of=/home/yr/桌面/test/bochs/hd6aM.img   of 是 output file 的缩写，用于指定输出文件的路径。这里指定的输出文件是 /home/yr/桌面/test/bochs/hd6aM.img，即把从输入文件读取的数据写入到该文件中。
bs=512  ，bs 是 block size 的缩写，用于指定每次读写操作的数据块大小。这里设置为 512 字节，意味着 dd 命令每次从输入文件读取 512 字节的数据，然后将这 512 字节的数据写入到输出文件中。（MBR为512字节）
count=1， count 用于指定读取的数据块数量。这里设置为 1，表示只读取 1 个数据块，结合 bs=512，也就是总共读取 512 字节的数据。
conv=notrunc ，conv 用于指定数据转换的方式，notrunc 是其中一个转换选项。notrunc 表示不截断输出文件，即写入数据时不会清除输出文件中原有内容，而是将新数据追加或覆盖到相应位置。

![1737892258812](C:\Users\24295\AppData\Roaming\Typora\typora-user-images\1737892258812.png)